default_platform(:android)

platform :android do
  desc "Build and sign APK for F-Droid"
  lane :fdroid_release do
    gradle(task: "clean assembleRelease")

    unsigned_apk = File.expand_path("../app/build/outputs/apk/release/app-release-unsigned.apk")
    aligned_apk = File.expand_path("../app/build/outputs/apk/release/app-release-aligned.apk")
    signed_apk = File.expand_path("../app/build/outputs/apk/release/app-release-signed.apk")

    sleep(1) # avoid zipalign race condition

    unless File.exist?(unsigned_apk)
      UI.user_error!("‚ùå APK not found at: #{unsigned_apk}")
    end

    # Align the APK
    sh("zipalign -v -p 4 #{unsigned_apk} #{aligned_apk}")

    keystore_path = File.expand_path(ENV["KEYSTORE_PATH"])
    key_alias = ENV["KEY_ALIAS"]
    keystore_password = ENV["KEYSTORE_PASSWORD"]
    key_password = ENV["KEY_PASSWORD"]

    # Sign the APK
    sh "apksigner sign " \
       "--ks #{keystore_path} " \
       "--ks-key-alias #{key_alias} " \
       "--ks-pass pass:#{keystore_password} " \
       "--key-pass pass:#{key_password} " \
       "--out #{signed_apk} #{aligned_apk}"

    # Verify signature
    sh("apksigner verify #{signed_apk}")

    # Get versionName from Gradle
    version_name = gradle(task: "printVersionName", print_command: false, quiet: true).strip

    # Calculate SHA256
    require 'digest'
    sha256 = Digest::SHA256.file(signed_apk).hexdigest
    puts("üîê SHA256: #{sha256}")

    # Output to release folder with new name
    sh("mkdir -p release")
    final_apk_name = "Permissions Summary V#{version_name}.apk"
    final_apk_path = File.join("release", final_apk_name)
    sh("cp #{signed_apk} \"#{final_apk_path}\"")

    UI.success("‚úÖ F-Droid APK built and signed: #{final_apk_path}")
  end
end
